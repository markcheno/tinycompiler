from syntree import *

def transpy(n):
    funname  = n.name
    funscope = n.deco['scope']
    funlabel = n.deco['label']
    nscopes  = n.deco['scope_cnt']
    allocvars = '\n'.join([f'stack.append( None ) # {v}' for v,t in n.var]) or 'pass'
    return fun(n) + (f'\n'
                     f'eax, ebx = None, None\n'
                     f'display = [ 65536 ]*{nscopes}\n' # 65536 is just a big number to increase chances of "out of range" error
                     f'stack = []\n'                    # while accessing the stack in a code generated by a bugged transpiler
                     f'display[{funscope}] = len(stack) # frame pointer for fun {funname}\n'
                     f'{allocvars}\n'
                     f'{funlabel}()\n')

def fun(n):
    nestedfun = '\n'.join([fun(f) for f in n.fun])
    funbody   = '\n'.join([stat(s) for s in n.body])
    return ('def %s():\n' % n.deco['label'] +
            indent(f'global eax, ebx, stack, display\n'
                   f'{nestedfun}\n'
                   f'{funbody}'))

def stat(n):
    if isinstance(n, Print):
        return '%sprint(eax, end=%s)\n' % (expr(n.expr), "'\\n'" if n.newline else "''")
    elif isinstance(n, Return):
        return '%sreturn eax\n' % expr(n.expr) if n.expr is not None else ''
    elif isinstance(n, Assign):
        return '%sstack[display[%d]+%d] = eax # %s\n' % (expr(n.expr), n.deco['scope'], n.deco['offset'], n.name)
    elif isinstance(n, FunCall):
        return expr(n)
    elif isinstance(n, While): # note the expr(n.expr) at the end of the loop body, we need to update eax
        return '%swhile eax:\n' % expr(n.expr) + indent(([stat(s) for s in n.body] or 'pass\n') + ['%s\n'%expr(n.expr)])
    elif isinstance(n, IfThenElse):
        return '%sif eax:\n%selse:\n%s' % (expr(n.expr),
                                        indent([stat(s) for s in n.ibody] or 'pass\n'),
                                        indent([stat(s) for s in n.ebody] or 'pass\n'))
    raise Exception('Unknown statement type', n)

def expr(n): # convention: all expressions save their results to eax
    if isinstance(n, ArithOp) or isinstance(n, LogicOp):
        pyeq = {'/':'//', '||':'or', '&&':'and'}
        pyop = pyeq[n.op] if n.op in pyeq else n.op
        left  = expr(n.left)
        right = expr(n.right)
        return (f'{left}'
                f'stack.append(eax) # evaluate left argument and stash it\n'
                f'{right}'
                f'ebx = eax # evaluate right arg\n'
                f'eax = stack.pop() # recall left arg\n'
                f'eax = eax {pyop} ebx # binary operation\n')
    elif isinstance(n, Integer) or isinstance(n, Boolean):
        return 'eax = %s\n' % str(n.value)
    elif isinstance(n, String):
        return 'eax = "%s"\n' % str(n.value)
    elif isinstance(n, Var):
        return 'eax = stack[display[%d]+%d] # %s\n' % (n.deco['scope'], n.deco['offset'], n.name)
    elif isinstance(n, FunCall):
        funname   = n.name
        funscope  = n.deco['fundeco']['scope']
        funlabel  = n.deco['fundeco']['label']
        disphead  = len(n.args)+len(n.deco['fundeco']['local'])+1
        allocargs = '\n'.join(['%sstack.append(eax)' % expr(s) for s in n.args])
        allocvars = '\n'.join([f'stack.append( None ) # {v}' for v in n.deco['fundeco']['local']]) or 'pass'
        freemem   = 'del stack[-%d]' % (disphead-1) if disphead>1 else 'pass'
        return (f'# prepare {funname}() call\n'
                f'# evalaute function arguments\n'
                f'{allocargs}\n'
                f'# reserve local variables\n'
                f'{allocvars}\n'
                f'stack.append(display[{funscope}]) # save old frame pointer\n'
                f'display[{funscope}] = len(stack)-{disphead} # activate new frame pointer\n'
                f'eax = {funlabel}()\n'
                f'display[{funscope}] = stack.pop() # restore old frame pointer\n'
                f'{freemem} # delete fun args and local vars if any, thus finishing {funname}() call\n')
    raise Exception('Unknown expression type', n)

def indent(array):
    multiline = ''.join([str(entry) for entry in array])
    if multiline == '': return ''
    return '\t'+'\n\t'.join(multiline.splitlines()) + '\n'
